function latLng2Point(latLng, map) {
	const topRight = map.getProjection().fromLatLngToPoint(map.getBounds().getNorthEast());
	const bottomLeft = map.getProjection().fromLatLngToPoint(map.getBounds().getSouthWest());
	const scale = Math.pow(2, map.getZoom());
	const worldPoint = map.getProjection().fromLatLngToPoint(latLng);

	return new google.maps.Point((worldPoint.x - bottomLeft.x) * scale, (worldPoint.y - topRight.y) * scale);
}

class Map {
	constructor(vis, e) {
		const mapOptions = {
			zoom: 11
		};

		this.vis = vis;
		this.map = new google.maps.Map(e, mapOptions);

		google.maps.event.addListener(this.map, 'mousemove', this._onMouseMove.bind(this));
		google.maps.event.addListener(this.map, 'mouseout', this._onMouseOut.bind(this));
		google.maps.event.addListener(this.map, 'click', this._onClick.bind(this));

		this.circle = null;
		this.activeRoute = null;
	}

	_getColor(speed) {
		const value = speed / 15;
	    const hue = ((1 - value) * 120).toString(10);

	    return `hsl(${Math.round(hue)},100%,50%)`;
	}

	createMarker(position, icon = null) {
		return new google.maps.Marker({
			position: position,
			optimized: false,
			map: this.map,
			icon: icon,
			zIndex: 200
		});
	}

	createPolyline(route) {
		const path = route.smoothPath;

		if(SPEED_COLORING) {
			const polylines = [];

			for(let i = 1; i < path.length; i++) {
				let gPath = [];

				let speed = path[i - 1].speed;
				for(;i < path.length; i++) {
					gPath.push(path[i - 1]);
					gPath.push(path[i]);

					if(path[i].speed != speed) {
						break;
					}
				}

				polylines.push(new google.maps.Polyline({
					path: gPath,
					geodesic: true,
					strokeColor: this._getColor(path[i - 1].speed),
					strokeOpacity: lineOptions.strokeOpacity,
					strokeWeight: lineOptions.strokeWeight,
					map: this.map
				}));	
			}

			return new PolylineGroup(polylines);
		} else {
			const gPath = [];

			for(let j = 0; j < path.length; j++) {
				gPath.push(new google.maps.LatLng(path[j].lat, path[j].lng));
			}

			return new google.maps.Polyline({
				path: gPath,
				geodesic: true,
				strokeColor: '#FF0000',
				strokeOpacity: 0.2,
				strokeWeight: 1,
				map: this.map
			});
		}
	}

	_onMouseOut(e) {
		if(this.circle != null) {
			this.circle.setMap(null);
			this.circle = null;
		}

		if(this.label) {
			this.label.hide();
		}
	}

	_onMouseMove(e) {
		const latLng = new LatLng(e.latLng.lat(), e.latLng.lng());
		const point = this.vis.routes.findNearestPoint(latLng, false);
		const exactPoint = this.vis.routes.findNearestPoint(latLng, true);
		
		if(this.circle == null) {
			this.circle = new google.maps.Circle({
				center: new google.maps.LatLng(exactPoint.position.lat, exactPoint.position.lng),
				radius: 150,
				fillColor: 'transparent',
				strokeWeight: 1,
				strokeColor: '#000000',
				clickable: false,
				map: this.map
			});
		} else {
			this.circle.setCenter(exactPoint.position);
		}

		if(this.label == null) {
			this.label = $('<div>').attr('id', 'label').css({
				position: 'absolute',
				pointerEvents: 'none',
				border: '4px solid transparent'
			});

			this.label.appendTo($('#gps-map'));
		}

		const route = this.vis.getRoute(point.route);

		const kn = route.data[point.point].speed;
		const time = moment.unix(route.data[point.point].time).format('DD.MM. YYYY HH:mm');

		const pos = latLng2Point(new google.maps.LatLng(exactPoint.position.lat, exactPoint.position.lng), this.map);
		const text = `<p>${time}</p><p>${kn}kn</p>`;

		this.label.html(text).css({
			left: pos.x + 10,
			top: pos.y - 10,
			borderColor: route.color
		}).show();
	}

	_onClick(e) {
		const latLng = new LatLng(e.latLng.lat(), e.latLng.lng());

		const p = this.vis.routes.findNearestPoint(latLng);
		const sp = this.vis.routes.findNearestPoint(latLng, true);
		
		this.vis.setMarkerExact(sp.position, this.vis.getRoute(p.route).pointToString(p.point));
		this.vis.setActiveRoute(sp.route);
		this.vis.setSliderValue(p.slider);
	}

	fitBounds(bounds) {
		this.map.fitBounds(bounds);
	}
}

class PolylineGroup {
	constructor(polylines) {
		this.polylines = polylines;
	}

	setOptions(opts) {
		for(const pl of this.polylines) {
			pl.setOptions(opts);
		}
	}
}
class Route {
	constructor(data) {
		$.extend(this, data);
	}

	pointToString(p) {
		let text = moment.unix(this.data[p].time).format('DD.MM. YYYY HH:mm');
		
		text += " " + this.data[p].speed + 'kn';
		text += " " + this.travel[p].toFixed(2) + "km / " + this.traveled.toFixed(2) + "km";
		
		return text;
	}

	toString() {
		let text = moment.unix(this.data[0].time).format('DD.MM. YYYY HH:mm');
		text += " - " + moment.unix(this.data[this.data.length - 1].time).format('DD.MM. YYYY HH:mm');
		text += " / " + this.traveled.toFixed(2) + "km";
		
		return text;
	}
}

class Routes {
	constructor(routes) {
		this._routes = routes;
		this._totalCount = 0;

		let hue = 20;
		for(const route of routes) {
			this._totalCount += route.count;

			route.color = `hsl(${Math.round(hue)},100%,50%)`;

			hue += 50;
		}
	}

	get routes() {
		return this._routes;
	}

	get totalCount() {
		return this._totalCount;
	}

	get firstPoint() {;
		return this._routes[0].data[0];
	}

	get lastPoint() {
		const l = this._routes[this._routes.length - 1];
		return l.data[l.data.length - 1];
	}

	getBounds() {
		let s, n, e, w;

		s = n = this._routes[0].data[0].lat;
		w = e = this._routes[0].data[0].lng;

		for(let i in this._routes) {
			for(let j in this._routes[i].data) {
				const p = this._routes[i].data[j];

				if(p.lat < s) {
					s = p.lat;
				}
				
				if(p.lat > n) {
					n = p.lat;
				}
				
				if(p.lng > e) {
					e = p.lng;
				}
				
				if(p.lng < w) {
					w = p.lng;
				}
			}
		}

		return {
			north: n,
			south: s,
			west: w,
			east: e
		};
	}

	findRoutePointSliderValue(r, p) {
		let s = 0;

		for(let i = 0; i < this._routes.length; i++) {
			for(let j = 0; j < this._routes[i].count; j++) {
				if(i == r && j == p) {
					return s;
				}
				
				s++;
			}
		}
		
		return null;
	}
			
	findCoordinateFromTime(time) {
		let s = 0;

		for(let i = 0; i < this._routes.length; i++) {
			for(let j = 0; j < this._routes[i].count; j++) {
				if(this._routes[i].data[j].time > time) {
					return {
						route: i,
						point: j,
						slider: s,
						position: new google.maps.LatLng(this._routes[i].data[j].lat, this._routes[i].data[j].lng)
					};
				}
				
				s++;
			}
		}
		
		return null;
	}
		
	findNearestPoint(p, smooth) {
		let route = 0;
		let point = 0;
		let s = 0;
		let ps = 0;

		const path = (smooth ? 'smoothPath' : 'data'); 

		let min = LatLng.distance(this._routes[0][path][0], p);
		
		for(let i = 0; i < this._routes.length; i++) {
			for(let j = 0; j < this._routes[i][path].length; j++) {
				const d = LatLng.distance(this._routes[i][path][j], p);

				if(d < min) {
					min = d;
					route = i;
					point = j;
					ps = s;
				}
				
				s++;
			}
		}

		return {
			route: route,
			point: point,
			position: this._routes[route][path][point],
			slider: ps
		};
	}
}
const SPEED_COLORING = true;

const lineOptions = {strokeOpacity: 0.3, strokeWeight: 2};
const selectedLineOptions = {strokeOpacity: 1, strokeWeight: 3};

function smooth(points) {
	let i, t, ax, ay, bx, by, cx, cy, dx, dy, lat, lon;
	let nPoints = [];
	
	let p = points[0];
	nPoints.push({lat: p.lat, lng: p.lng, speed: p.speed, course: p.course});
	
	for (i = 2; i < points.length - 2; i++) {
		for (t = 0; t < 1; t += 0.2) {
			ax = (-points[i - 2].lat + 3 * points[i - 1].lat - 3 * points[i].lat + points[i + 1].lat) / 6;
			ay = (-points[i - 2].lng + 3 * points[i - 1].lng - 3 * points[i].lng + points[i + 1].lng) / 6;
			bx = (points[i - 2].lat - 2 * points[i - 1].lat + points[i].lat) / 2;
			by = (points[i - 2].lng - 2 * points[i - 1].lng + points[i].lng) / 2;
			cx = (-points[i - 2].lat + points[i].lat) / 2;
			cy = (-points[i - 2].lng + points[i].lng) / 2;
			dx = (points[i - 2].lat + 4 * points[i - 1].lat + points[i].lat) / 6;
			dy = (points[i - 2].lng + 4 * points[i - 1].lng + points[i].lng) / 6;
			lat = ax * Math.pow(t + 0.1, 3) + bx * Math.pow(t + 0.1, 2) + cx * (t + 0.1) + dx;
			lon = ay * Math.pow(t + 0.1, 3) + by * Math.pow(t + 0.1, 2) + cy * (t + 0.1) + dy;

			nPoints.push({lat: lat, lng: lon, speed: points[i].speed, course: points[i].course});
		}
	}
	
	p = points[points.length - 1];
	nPoints.push({lat: p.lat, lng: p.lng, speed: p.speed, course: p.course});

	return nPoints;
}

class Visualizer {
	constructor(e, markerOpts) {
		this.routes = null;
		this.activeRoute = null;
		this.markerOpts = markerOpts;
		
		this.map = new Map(this, e);
	}

	getRoutes() {
		return this.routes;
	}

	getRoute(r) {
		return this.routes.routes[r];
	}

	_generateSmoothPoints() {
		for(let route of this.routes.routes) {
			route.smoothPath = smooth(route.data);
		}
	}

	setActiveRoute(i) {
		if(i !== this.activeRoute) {
			this.routes.routes[i].polyline.setOptions(selectedLineOptions);
			
			if(this.activeRoute !== null) {
				this.routes.routes[this.activeRoute].polyline.setOptions(lineOptions);
			}
			
			this.activeRoute = i;

			$('#gps-routes li').removeClass('active');
			$('#gps-routes li:nth-child(' + (i + 1) + ')').addClass('active');
		}
	}

	setSliderValue(v) {
		$('#gps-slider').slider('value', v);
	}

	setMarkerPosition(i, a) {
		const route = this.routes.routes[i];
		const path = route.data[a];
			
		this.marker.setPosition(new google.maps.LatLng(path.lat, path.lng));
		
		$('#gps-date').text(route.pointToString(a));
		
		const icon = { 
			path: this.markerOpts.path,
			scale: this.markerOpts.scale,
			rotation: Number(route.data[a].course)
		};
		
		this.marker.setIcon(icon);
	}

	setMarkerExact(point, text) {
		this.marker.setPosition(new google.maps.LatLng(point.lat, point.lng));
		
		const icon = { 
			path: this.markerOpts.path,
			scale: this.markerOpts.scale,
			rotation: Number(point.course)
		};
		
		$('#gps-date').text(text);
		
		this.marker.setIcon(icon);
	}

	_routify(data) {
		const routeArray = [];

		for(let d of data) {
			routeArray.push(new Route(d));
		}

		return new Routes(routeArray);
	}

	_generateTitle() {
		let text = moment.unix(this.routes.firstPoint.time).format('D.M. YYYY');
		text += "- " + moment.unix(this.routes.lastPoint.time).format('D.M. YYYY');
		
		let km = 0;

		for(let i = 0; i < this.routes.routes.length; i++) {
			km += this.routes.routes[i].traveled;
		}
		
		text += ' / ' + km.toFixed(2) + 'km';
		
		$('#gps-title').text(text);
	}

	loadRoutes(file) {
		return new Promise((resolve, reject) => {
			$.getJSON(file, (data) => {
				this.routes = this._routify(data);

				this._generateTitle();

				for(const route of this.routes.routes) {
					for(const j in route.path) {
						route.path[j].speed = route.data[j].speed;
					}
				}

				this._generateSmoothPoints();

				
				for(const i in this.routes.routes) {
					const route = this.routes.routes[i];

					route.polyline = this.map.createPolyline(route);

					const text = route.toString();
					const li = $('<li>');

					li.append($('<div>').css({
						width: 13,
						height: 13,
						marginRight: 5,
						float: 'left',
						background: route.color
					}));

					li.append($('<div>').text(text)).data('route', i);

					li.click(e => {
						const r = Number($(e.currentTarget).data('route'));

						this.setActiveRoute(r);
						this.setMarkerPosition(r, 0);
						this.setSliderValue(this.routes.findRoutePointSliderValue(r, 0));
					});
					
					$('#gps-routes').append(li);
				}

				const path = this.routes.routes[0].data[0];

				this.marker = this.map.createMarker(path, {
					path: this.markerOpts.path,
					scale: this.markerOpts.scale,
					rotation: Number(this.routes.routes[0].data[0].course)
				});

				let remaining = 100;
				for(const route of this.routes.routes) {
					const p = Math.ceil(route.count / this.routes.totalCount * 100);

					const div = $('<div>').css({
						width:  Math.min(p, remaining) + '%',
						height: '15px',
						float: 'left',
						background: route.color
					});

					remaining -= p;

					$('#gps-slider').append(div);
				}

				$('#gps-slider').slider({
					value: 0,
					min: 0,
					max: this.routes.totalCount - 1,

					slide: (e, ui) => {
						var a = 0;
						for(var i = 0; i < this.routes.routes.length; i++) {
							if(a + this.routes.routes[i].count > ui.value) {
								break;
							}
							
							a += this.routes.routes[i].count;
						}
						
						a = ui.value - a;
						
						this.setActiveRoute(i);
						this.setMarkerPosition(i, a);
					}
				});

				this.setActiveRoute(0);
				this.setMarkerPosition(0, 0);

				resolve();
			});
		});
	}

	fitBounds() {
		this.map.map.fitBounds(this.routes.getBounds());
	}
}
function toRad(n) {
	return n * Math.PI / 180;
}

class LatLng {
	constructor(lat, lng) {
		this.lat = Number(lat);
		this.lng = Number(lng);
	}

	distance(p) {
		return LatLng.distance(this, p);
	}

	static distance(p1, p2) {
		const R = 6371;

		const dLat = toRad(p1.lat - p2.lat),
			dLon = toRad(p1.lng - p2.lng),
			lat1 = toRad(p1.lat),
			lat2 = toRad(p2.lat);

		const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.sin(dLon/2) * Math.sin(dLon/2) * Math.cos(lat1) * Math.cos(lat2); 
		const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
		
		return R * c;
	}
}

if(typeof module !== 'undefined') {
	module.exports = LatLng;
}